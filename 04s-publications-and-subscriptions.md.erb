---
title: Publicaties en Abonnementen
slug: publications-and-subscriptions
date: 0004/01/02
number: 4.5
points: 5
sidebar: true
photoUrl: http://www.flickr.com/photos/ikewinski/11264732804/
photoAuthor: Mike Lewinski
contents: Begrijp hoe publicaties en abonnementen werken.|Leer wat het standaard pakket Autopublish doet.|Bekijk een aantal voorbeelden van publicatie patronen.
paragraphs: 52
---

Publicaties en abonnementen zijn een van de meest fundamentele en belangrijke concepten in Meteor, maar kunnen lastig zijn om te begrijpen als je net begint.

Dit heeft geleid tot veel misverstanden, zoals de veronderstelling dat Meteor onveilig is, of dat Meteor apps niet kunnen omgaan met grote hoeveelheden data.

Een groot deel van de reden waarom mensen deze concepten in eerste instantie verwarrend vinden is de "magie" die Meteor voor ons uitvoert. Hoewel deze magie uiteindelijk erg bruikbaar is, kan het de blik vervuilen op wat er achter de schermen gebeurd (zoals magie neigt te doen). Dus laten we de lagen magie weghalen en proberen te begrijpen wat er gebeurd.

### Vroeger

Maar laten we eerst eens terugkijken naar de mooie dagen van 2011 toen Meteor nog niet bestond. Laten we zeggen dat je een simpele Rails app aan het bouwen bent. Wanneer een gebruiker op je site komt, dan stuurt de client (d.w.z. de browser) een verzoek naar je app, welke leeft op de server.

Het eerste wat de app moet doen, is zien uit te vinden welke data de gebruiker moet zien. Dit kan pagina 12 van wat zoek resultaten zijn, Maria's gebruikers profiel informatie, Bob's laatste 20 tweets, enzovoort. Je kunt het zien als een boekenwinkel bediende die door de planken gaat om het boek te vinden waar je om gevraagd hebt.

Als de correcte data geselecteerd is, is het tweede wat de app moet doen, het vertalen van de data in mooie, door mensen te lezen HTML (of JSON in het geval van een API).

In de metafoor van de boekenwinkel, zou dat het inpakken van het boek dat je zojuist gekocht hebt betekenen en deze in een mooie tas stoppen. Dit is het "View" onderdeel van het fameuze Model-View-Controller model.

Uiteindelijk neemt de app de HTML code en stuurt dit naar de browser. De taak van de app is gedaan en nu dat het hele ding uit z'n virtuele handen is gegeven kan het lekker uitrusten met een biertje terwijl het wacht op het volgende verzoek.

### De Meteor Manier

Laten we eens kijken wat Meteor zo speciaal maakt als we deze vergelijken. Zoals we gezien hebben, is de sleutel tot de innovatie van Meteor, dat een Rails app enkel **op de server** leeft en een Meteor app ook de client-zijde compenenten bevat, die draaien **op de client** (de browser).

<%= diagram "client-server", "Het doorzetten van de deelverzameling naar de client.", "pull-right" %>

Dit is als een winkel bediende die niet alleen het juiste boek voor je vind, maar je ook naar huis volgt om het boek 's avonds voor te lezen (toegegeven, dat klinkt een beetje eng).

Deze architectuur laat Meteor een hoop coole dingen doen, met de baas onder hen wat Meteor [database everywhere](http://docs.meteor.com/#sevenprinciples) noemt. Simpel gezegd, Meteor neemt een subset van je database en *kopieert deze naar de client*.

Dit heeft twee grote gevolgen: als eerste, inplaats van HTML code naar de client te sturen, stuurt een Meteor app **de eigenlijke, ruwe data** en laat de client dit afhandelen ([data on the wire](http://docs.meteor.com/#sevenprinciples)). Ten tweede, stelt dit je in staat om **deze data direct te benaderen** zonder te hoeven wachten op een ritje naar de server ([latency compensation](http://docs.meteor.com/#sevenprinciples)).

### Publiseren

Een app's database can tien duizenden documenten bevatten, waarvan sommigen zelfs prive of gevoelig kunnen zijn. Dus we kunnen uiteraard niet de hele database zomaar naar de client sturen, voor zowel veiligheids als schaalbaarheids redenen.

Dus we hebben een manier nodig om Meteor te vertellen welke **subset** van data naar de client gestuurd kan worden, en we bereiken dit door middel van een **publicatie**.

Laten we teruggaan naar Microscope. Hier zijn al onze berichten die in de database zitten:

<%= diagram "collections-1", "Alle berichten opgeslagen in onze database.", "pull-center" %>

Hoewel deze functie weliswaar niet echt bestaat in Microscope, stellen we ons voor dat sommigen van onze berichten gemarkeerd zijn voor beledigende taal. Hoewl we deze berichten in onze database willen houden, dienen ze niet beschikbaar te worden gemaakt voor onze gebruikers (d.w.z. naar een client verstuurd).

Ons eerste gesrpek zal Meteor vertellen welke data we *wel* naar de client willen versturen. Later vertellen we Meteor dat we alleen ongemarkeerde berichten willen **publiceren**.

<%= diagram "collections-2", "Gemarkeerde berichten uitsluiten.", "pull-center" %>

Hier is de corresponderende code, welke op de server verblijft:

~~~js
// on the server
Meteor.publish('posts', function() {
  return Posts.find({flagged: false});
});
~~~

Dit verzekert dat er **geen enkele manier mogelijk** is dat een client toegang kan verkrijgen tot een gemarkeerd bericht. Dit is precies hoe je een Meteor app veilig maakt: zorg er gewoon voor dat je allen data publiceert waar je de huidige client toegang tot wilt geven.

<% note do %>

### DDP

Fundamentally, you can think of the publication/subscription system as a funnel that transfers data from a server-side (source) collection to a client-side (target) collection.

The protocol that is spoken over that funnel is called **DDP** (which stands for Distributed Data Protocol). To learn more about DDP, you can watch [this talk from The Real-time Conference](http://2012.realtimeconf.com/video/matt-debergalis) by Matt DeBergalis (one of the founders of Meteor), or [this screencast](http://www.eventedmind.com/posts/meteor-subscriptions-and-ddp) by Chris Mather that walks you through this concept in a little more detail.

<% end %>

### Subscribing

Even though we want to make any non-flagged post available to clients, we can't just send thousands of posts at once. We need a way for clients to specify which subset of that data they need at any particular moment, and that's exactly where **subscriptions** come in.

Any data you subscribe to will be **mirrored** on the client thanks to Minimongo, Meteor's client-side implementation of MongoDB.

For example, let's say we're currently browsing Bob Smith's profile page, and only want to display *his* posts.

<%= diagram "collections-3", "Subscribing to Bob's posts will mirror them on the client.", "pull-center" %>

First, we would amend our publication to take a parameter:

~~~js
// on the server
Meteor.publish('posts', function(author) {
  return Posts.find({flagged: false, author: author});
});
~~~

And we would then define that parameter when we *subscribe* to that publication in our app's client-side code:

~~~js
// on the client
Meteor.subscribe('posts', 'bob-smith');
~~~

This is how you make a Meteor app scalable client-side: instead of subscribing to *all* available data, just pick and choose the parts that you currently need. This way, you'll avoid overloading the browser's memory no matter how big your server-side database is.

### Finding

Now Bob's posts happen to be spread across multiple categories (for example: “JavaScript”, ”Ruby”, and ”Python”). Maybe we still want to load all of Bob's posts in memory, but we only want to display those from the “JavaScript" category right now. This is where “finding” comes in.

<%= diagram "collections-4", "Selecting a subset of documents on the client.", "pull-center" %>

Just like we did on the server, we'll use the `Posts.find()` function to select a subset of our data:

~~~js
// on the client
Template.posts.helpers({
	posts: function(){
		return Posts.find({author: 'bob-smith', category: 'JavaScript'});
	}
});
~~~

Now that we have a good grasp of what role publications and subscriptions play, let's dig in deeper and review a few common implementation patterns.

### Autopublish

If you create a Meteor project from scratch (i.e using `meteor create`), it will automatically have the `autopublish` package enabled. As a starting point, let's talk about what that does exactly.

The goal of `autopublish` is to make it very easy to get started coding your Meteor app, and it does this by automatically mirroring _all data_ from the server on the client, thus taking care of publications and subscriptions for you.

<%= diagram "autopublish", "Autopublish", "pull-center"%>

How does this work? Suppose you have a collection called `'posts'` on the server. Then `autopublish` will automatically send every post that it finds in the Mongo posts collection into a collection called `'posts'` on the client (assuming there is one).

So if you are using `autopublish`, you don't need to think about publications. Data is ubiquitous, and things are simple. Of course, there are obvious problems with having a complete copy of your app's database cached on every user's machine.

For this reason, autopublish is only appropriate when you are starting out, and haven't yet thought about publications.

### Publishing Full Collections

Once you remove `autopublish`, you'll quickly realize that all your data has vanished from the client. An easy way to get it back is to simply duplicate what autopublish does, and publish a collection in its entirety. For example:

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find();
});
~~~

<%= diagram "fullcollection", "Publishing a full collection", "pull-center" %>

We're still publishing full collections, but at least we now have control over which collections we publish or not. In this case, we're publishing the `Posts` collection but not `Comments`.

### Publishing Partial Collections

The next level of control is publishing only _part_ of a collection. For example only the posts that belong to a certain author:

~~~js
Meteor.publish('somePosts', function(){
  return Posts.find({'author':'Tom'});
});
~~~

<%= diagram "partialcollection", "Publishing a partial collection", "pull-center" %>

<% note do %>

### Behind The Scenes

If you've read the [Meteor publication documentation](http://docs.meteor.com/#publishandsubscribe), you were perhaps overwhelmed by talk of using `added()` and `ready()` to set attributes of records on the client, and struggled to square that with the Meteor apps that you've seen that never use those methods.

The reason is that Meteor provides a very important convenience: the `_publishCursor()` method. You've never seen that used either? Perhaps not directly, but if you return a [cursor](/chapter/meteor-vocabulary/) (i.e. `Posts.find({'author':'Tom'})`) in a publish function, that's exactly what Meteor is using.

When Meteor sees that the `somePosts` publication has returned a cursor, it calls `_publishCursor()` to -- you guessed it -- publish that cursor automatically.

Here's what `_publishCursor()` does:

- It checks the name of the server-side collection.
- It pulls all matching documents from the cursor and sends it into a client-side collection *of the same name*. (It uses `.added()` to do this).
- Whenever a document is added, removed or changed, it sends those changes down to the client-side collection. (It uses `.observe()` on the cursor and `.added()`, `.changed()` and `removed()` to do this).

So in the example above, we are able to make sure that the user only has the posts that they are interested in (the ones written by Tom) available to them in their client side cache.

<% end %>

### Publishing Partial Properties

We've seen how to only publish some of our posts, but we can keep slicing thinner! Let's see how to only publish specific *properties*.

Just like before, we'll use `find()` to return a cursor, but this time we'll exclude certain fields:

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({}, {fields: {
    date: false
  }});
});
~~~

<%= diagram "partialproperties", "Publishing partial properties", "pull-center" %>

Of course, we can also combine both techniques. For example, if we wanted to return all posts by Tom while leaving aside their dates, we would write:

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({'author':'Tom'}, {fields: {
    date: false
  }});
});
~~~

### Summing Up

So we've seen how to go from publishing every property of all documents of every collection (with `autopublish`) to publishing only _some_ properties of _some_ documents of _some_ collections.

This covers the basics of what you can do with Meteor publications, and these simple techniques should take care of the vast majority of use cases.

Sometimes, you'll need to go further by combining, linking, or merging publications. We will cover these in a later chapter!
