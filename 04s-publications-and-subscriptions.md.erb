---
title: Publicaties en Abonnementen
slug: publications-and-subscriptions
date: 0004/01/02
number: 4.5
points: 5
sidebar: true
photoUrl: http://www.flickr.com/photos/ikewinski/11264732804/
photoAuthor: Mike Lewinski
contents: Begrijp hoe publicaties en abonnementen werken.|Leer wat het standaard pakket Autopublish doet.|Bekijk een aantal voorbeelden van publicatie patronen.
paragraphs: 52
---

Publicaties en abonnementen zijn een van de meest fundamentele en belangrijke concepten in Meteor, maar kunnen lastig zijn om te begrijpen als je net begint.

Dit heeft geleid tot veel misverstanden, zoals de veronderstelling dat Meteor onveilig is, of dat Meteor apps niet kunnen omgaan met grote hoeveelheden data.

Een groot deel van de reden waarom mensen deze concepten in eerste instantie verwarrend vinden is de "magie" die Meteor voor ons uitvoert. Hoewel deze magie uiteindelijk erg bruikbaar is, kan het de blik vervuilen op wat er achter de schermen gebeurd (zoals magie neigt te doen). Dus laten we de lagen magie weghalen en proberen te begrijpen wat er gebeurd.

### Vroeger

Maar laten we eerst eens terugkijken naar de mooie dagen van 2011 toen Meteor nog niet bestond. Laten we zeggen dat je een simpele Rails app aan het bouwen bent. Wanneer een gebruiker op je site komt, dan stuurt de client (d.w.z. de browser) een verzoek naar je app, welke leeft op de server.

Het eerste wat de app moet doen, is zien uit te vinden welke data de gebruiker moet zien. Dit kan pagina 12 van wat zoek resultaten zijn, Maria's gebruikers profiel informatie, Bob's laatste 20 tweets, enzovoort. Je kunt het zien als een boekenwinkel bediende die door de planken gaat om het boek te vinden waar je om gevraagd hebt.

Als de correcte data geselecteerd is, is het tweede wat de app moet doen, het vertalen van de data in mooie, door mensen te lezen HTML (of JSON in het geval van een API).

In de metafoor van de boekenwinkel, zou dat het inpakken van het boek dat je zojuist gekocht hebt betekenen en deze in een mooie tas stoppen. Dit is het "View" onderdeel van het fameuze Model-View-Controller model.

Uiteindelijk neemt de app de HTML code en stuurt dit naar de browser. De taak van de app is gedaan en nu dat het hele ding uit z'n virtuele handen is gegeven kan het lekker uitrusten met een biertje terwijl het wacht op het volgende verzoek.

### De Meteor Manier

Laten we eens kijken wat Meteor zo speciaal maakt als we deze vergelijken. Zoals we gezien hebben, is de sleutel tot de innovatie van Meteor, dat een Rails app enkel **op de server** leeft en een Meteor app ook de client-zijde compenenten bevat, die draaien **op de client** (de browser).

<%= diagram "client-server", "Het doorzetten van de deelverzameling naar de client.", "pull-right" %>

Dit is als een winkel bediende die niet alleen het juiste boek voor je vind, maar je ook naar huis volgt om het boek 's avonds voor te lezen (toegegeven, dat klinkt een beetje eng).

Deze architectuur laat Meteor een hoop coole dingen doen, met de baas onder hen wat Meteor [database everywhere](http://docs.meteor.com/#sevenprinciples) noemt. Simpel gezegd, Meteor neemt een subset van je database en *kopieert deze naar de client*.

Dit heeft twee grote gevolgen: als eerste, inplaats van HTML code naar de client te sturen, stuurt een Meteor app **de eigenlijke, ruwe data** en laat de client dit afhandelen ([data on the wire](http://docs.meteor.com/#sevenprinciples)). Ten tweede, stelt dit je in staat om **deze data direct te benaderen** zonder te hoeven wachten op een ritje naar de server ([latency compensation](http://docs.meteor.com/#sevenprinciples)).

### Publiseren

Een app's database can tien duizenden documenten bevatten, waarvan sommigen zelfs prive of gevoelig kunnen zijn. Dus we kunnen uiteraard niet de hele database zomaar naar de client sturen, voor zowel veiligheids als schaalbaarheids redenen.

Dus we hebben een manier nodig om Meteor te vertellen welke **subset** van data naar de client gestuurd kan worden, en we bereiken dit door middel van een **publicatie**.

Laten we teruggaan naar Microscope. Hier zijn al onze berichten die in de database zitten:

<%= diagram "collections-1", "Alle berichten opgeslagen in onze database.", "pull-center" %>

Hoewel deze functie weliswaar niet echt bestaat in Microscope, stellen we ons voor dat sommigen van onze berichten gemarkeerd zijn voor beledigende taal. Hoewl we deze berichten in onze database willen houden, dienen ze niet beschikbaar te worden gemaakt voor onze gebruikers (d.w.z. naar een client verstuurd).

Ons eerste gesrpek zal Meteor vertellen welke data we *wel* naar de client willen versturen. Later vertellen we Meteor dat we alleen ongemarkeerde berichten willen **publiceren**.

<%= diagram "collections-2", "Gemarkeerde berichten uitsluiten.", "pull-center" %>

Hier is de corresponderende code, welke op de server verblijft:

~~~js
// on the server
Meteor.publish('posts', function() {
  return Posts.find({flagged: false});
});
~~~

Dit verzekert dat er **geen enkele manier mogelijk** is dat een client toegang kan verkrijgen tot een gemarkeerd bericht. Dit is precies hoe je een Meteor app veilig maakt: zorg er gewoon voor dat je allen data publiceert waar je de huidige client toegang tot wilt geven.

<% note do %>

### DDP

In de basis, kun je aan het publicatie/abonnementen systeem denken als een trechter die data vanaf de server (bron) collectie naar een client (doel) collectie stuurt.

Het protocol wat door deze trechter wordt gesproken noemen we **DDP** (wat staat voor Distributed Data Protocol). Om meer over DDP te leren, kun je [deze sessie van The Real-time Conferentie](http://2012.realtimeconf.com/video/matt-debergalis) door Matt DeBergalis (een van de stichters van Meteor) bekijken, of [deze screencast](http://www.eventedmind.com/posts/meteor-subscriptions-and-ddp) door Chris Mahter welke dit contept in meer wat detail beschrijft.

<% end %>

### Abonneren

Ondanks dat we alle niet gemarkeerde berichten voor de clients beschikbaar willen maken, kunnen we niet zomaar duizenden berichten in een keer sturen. We hebben een manier nodig voor clients om te specificeren welke subset van deze data zij op een specifiek moment nodig hebben. En dat is precies waar we **abonnementen** nodig hebben.

Elke data waarop je je abonneert wordt **gespiegeld** op de client met dank aan Minimongo, Meteor's client-side implementatie van MongoDG.

Laten we bijvoorbeeld zeggen dat we op dit moment de profiel pagina van Bob Smith aan het bekijken zijn en we alleen *zijn* berichten willen zien.

<%= diagram "collections-3", "Abonneren op Bob's berichten zal deze spiegelen op de client.", "pull-center" %>

Als eerste, wijzigen we onze publicatie om een parameter te kunen ontvangen;

~~~js
// on the server
Meteor.publish('posts', function(author) {
  return Posts.find({flagged: false, author: author});
});
~~~

En zouden we deze parameter definieren wanneer we ons *abonneren* op die publicatie in de client-side code van onze app:

~~~js
// on the client
Meteor.subscribe('posts', 'bob-smith');
~~~

Dit is hoe je een Meteor app schaalbaar maakt aan de client kant: inplaats van te abonneren op *alle* beschikbare data, kiez je alleen de onderdelen die je op dit moment nodig hebt. Op deze manier, voorkom je het overbelasten van het geheugen van de browser, ongeacht hoe groot je server-side datbase is.

### Zoeken

Nu zijn Bob's berichten toevallig verspreid over meerdere categorien (bijvoorbeeld: "JavaScript", "Ruby" en "Python"). Misschien willen we nog steeds alle berichten van Bob in het geheugen laden, maar willen we alleen diegene tonen die de categorie "JavaScript" hebben op dit moment. Dat is waar "zoeken" nuttig is.

<%= diagram "collections-4", "Selecteer een subset van documenten op de client.", "pull-center" %>

Net zoals we op de server deden, gebruiken we de `Post.find()` functie om een subset van onze data te selecteren:

~~~js
// on the client
Template.posts.helpers({
	posts: function(){
		return Posts.find({author: 'bob-smith', category: 'JavaScript'});
	}
});
~~~

Nu dat we een goed begrip hebben van wat voor rol publicaties en abonnementen spelen, kunnen we wat dieper graven en een paar algemene inplementatie patronen.

### Autopublish

Als je vanuit niets een Meteor project maakt (d.w.z. met `meteor create`), heeft deze automatisch het `autopublish` package aanstaan. Laten we er van uitgangspunt eens bekijken wat dit exact doet.

Het doel van `autopublish` is om het erg makkelijk te maken om je te laten starten met het maken van je Meteor app, en het spiegeld automatisch _alle data- van de server naar de client, dus het verzorgt de publicaties en abonnementen voor je.

<%= diagram "autopublish", "Autopublish", "pull-center"%>

Hoe werkt dit? Stel je voor dat je een collectie genaamd `'berichten'` hebt op de server. Dan zal `autopublish` automatisch ieder bericht dat het vind in de Mongo berichten collectie sturen naarn een collectie genaamd `'berichten'` op de client (aangemonem dat er een is).

So if you are using `autopublish`, you don't need to think about publications. Data is ubiquitous, and things are simple. Of course, there are obvious problems with having a complete copy of your app's database cached on every user's machine.

Om deze reden, is autopublish alleen geschikt als je begint, and nog niet hebt nagedacht over pupliceren.

### Publiceren van Volledige Collecties

Als je `autopublish` eenmaal hebt verwijderd, zul je je snel realizeren dat al je data verdwenen is van de client. Een makkelijke manier om het terug te krijgen is om simpelweg te dupliceren wat autopublish doet, en een collectie volledig publiceren. bijvoorbeeld:

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find();
});
~~~

<%= diagram "fullcollection", "Publiceren van een volledige collectie", "pull-center" %>

We pucliceren nog steeds een volledige collectie, maar we hebben nu in ieder geval contole over het wel of niet publiceren van collecties. In dit geval, publiceren we de `Berichten` collectie maar niet `Commentaar`.

### Publiceer een Gedeeltelijke Collectie

Het volgende level van controle is om alleen een _gedeelte_ van een collectie te publiceren. Bijvoorbeeld alleen de berichten die horen bij een bepaalde auteur:

~~~js
Meteor.publish('somePosts', function(){
  return Posts.find({'author':'Tom'});
});
~~~

<%= diagram "partialcollection", "Publiceer een gedeeltelijke collectie", "pull-center" %>

<% note do %>

### Achter De Schermen

Als je [Meteor publication documentation](http://docs.meteor.com/#publishandsubscribe) gelezen hebt, was je misschien overweldigd door gesprekken over `added()` en `ready()` om attributen van records op de client te zetten en worstelde met het gegeven dat de Meteor apps die je hebt gezien deze methodes nooit gebruiken.

De reden hiervoor is dat Meteor je van een heel belangrijk gemak voorziet: de `_publishCursor()` methode. Je hebt dat nog nooit gebruikt zien worden? Misschien niet direct, maar als je een [cursor](/chapter/meteor-vocabulary/) (b.v. `Posts.find({'author':'Tom'})`) teruggeeft in een publiceer functie, dan is dat precies wat Meteor teruggeeft.

Wanneer Meteor ziet dat de `somePosts` publicatie een cursor teruggeeft, 
When Meteor sees that the `somePosts` publication has returned a cursor, it calls `_publishCursor()` to -- you guessed it -- publish that cursor automatically.

Here's what `_publishCursor()` does:

- It checks the name of the server-side collection.
- It pulls all matching documents from the cursor and sends it into a client-side collection *of the same name*. (It uses `.added()` to do this).
- Whenever a document is added, removed or changed, it sends those changes down to the client-side collection. (It uses `.observe()` on the cursor and `.added()`, `.changed()` and `removed()` to do this).

So in the example above, we are able to make sure that the user only has the posts that they are interested in (the ones written by Tom) available to them in their client side cache.

<% end %>

### Publishing Partial Properties

We've seen how to only publish some of our posts, but we can keep slicing thinner! Let's see how to only publish specific *properties*.

Just like before, we'll use `find()` to return a cursor, but this time we'll exclude certain fields:

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({}, {fields: {
    date: false
  }});
});
~~~

<%= diagram "partialproperties", "Publishing partial properties", "pull-center" %>

Of course, we can also combine both techniques. For example, if we wanted to return all posts by Tom while leaving aside their dates, we would write:

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({'author':'Tom'}, {fields: {
    date: false
  }});
});
~~~

### Summing Up

So we've seen how to go from publishing every property of all documents of every collection (with `autopublish`) to publishing only _some_ properties of _some_ documents of _some_ collections.

This covers the basics of what you can do with Meteor publications, and these simple techniques should take care of the vast majority of use cases.

Sometimes, you'll need to go further by combining, linking, or merging publications. We will cover these in a later chapter!
